package memphis.fridge.server.ioc;

import java.util.List;
import java.util.Map;

import com.google.common.collect.Maps;
import com.google.inject.servlet.RequestScoped;
import javax.inject.Inject;
import memphis.fridge.dao.NonceDAO;
import memphis.fridge.dao.UserDAO;
import memphis.fridge.domain.Nonce;
import memphis.fridge.domain.User;
import memphis.fridge.exceptions.AuthenticationException;
import memphis.fridge.utils.CryptUtils;

/**
 * Author: Stephen Nelson <stephen@sfnelson.org>
 * Date: 11/10/12
 */
@RequestScoped
public class SessionState {

	private static final String SIGNATURE = "fridge-signature";
	private static final String NEW_NONCE = "fridge-nonce-new";
	private static final String OLD_NONCE = "fridge-nonce-old";
	private static final String USERNAME = "fridge-username";
	private static final String NONCE = "fridge-nonce";

	@Inject
	UserDAO users;

	@Inject
	NonceDAO nonceStore;

	private boolean isAuthenticated;
	private User user;

	private boolean hasNonce;
	private String currentNonce;
	private String nextNonce;

	public void authenticate(Map<String, List<String>> params, String message) {
		if (!verify(params, message)) return;

		// consume the current nonce to prevent replay attacks
		String nonce = params.get(NONCE).get(0);
		this.nextNonce = nonceStore.consumeNonce(nonce);
		this.currentNonce = nonce;
	}

	public void nonceRequest(Map<String, List<String>> params) {
		int timestamp;
		try {
			timestamp = Integer.valueOf(params.get("fridge-timestamp").get(0));
		} catch (Exception ex) {
			throw new AuthenticationException("invalid timestamp");
		}
		if (!verify(params, String.valueOf(timestamp))) {
			throw new AuthenticationException("cannot request a nonce without authenticating");
		}

		String nonce = params.get(NONCE).get(0);
		Nonce n = nonceStore.generateNonce(nonce, timestamp);
		hasNonce = false; // this nonce was generated by the client, don't allow modifications
		currentNonce = n.getClientNonce();
		nextNonce = n.getServerNonce();
	}

	private boolean verify(Map<String, List<String>> params, String message) {

		// not signed unless it has username, nonce, and signature
		if (!params.containsKey(USERNAME) || params.get(USERNAME).isEmpty()) return false;
		if (!params.containsKey(NONCE) || params.get(NONCE).isEmpty()) return false;
		if (!params.containsKey(SIGNATURE) || params.get(SIGNATURE).isEmpty()) return false;

		String username = params.get(USERNAME).get(0);
		String nonce = params.get(NONCE).get(0);
		String signature = params.get(SIGNATURE).get(0);

		assert (user == null);
		assert username != null;
		assert nonce != null;
		assert signature != null;
		assert message != null;

		User user = users.retrieveUser(username);

		// throws an exception if the signature is invalid
		if (!signature.equals(CryptUtils.sign(user.getPassword(), username, nonce, message))) {
			throw new AuthenticationException();
		}

		// user is authenticated at this point
		this.isAuthenticated = true;
		this.user = user;

		return true;
	}

	public Map<String, String> sign(String message) {
		assert (user != null);
		assert message != null;

		String username = user.getUsername();
		String signature = CryptUtils.sign(user.getPassword(), username, currentNonce, nextNonce, message);

		Map<String, String> params = Maps.newHashMapWithExpectedSize(4);
		params.put(USERNAME, username);
		params.put(OLD_NONCE, currentNonce);
		params.put(NEW_NONCE, nextNonce);
		params.put(SIGNATURE, signature);
		return params;
	}

	public boolean isAuthenticated() {
		if (isAuthenticated) assert user != null;
		return isAuthenticated;
	}

	public boolean hasNonce() {
		assert user != null;
		return hasNonce;
	}

	public boolean isGrad() {
		assert (user != null);
		return user.isGrad();
	}

	public boolean isAdmin() {
		assert (user != null);
		return user.isAdmin();
	}

	public boolean isEnabled() {
		assert (user != null);
		return user.isEnabled();
	}

	public boolean isUserOrAdmin(String username) {
		assert (user != null);
		assert (username != null);
		return user.isAdmin() || user.getUsername().equals(username);
	}

	public User getUser() {
		return user;
	}
}
